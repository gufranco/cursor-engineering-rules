---
description: Core principles - always loaded
alwaysApply: true
---

# Core Principles

## Core Checklist (One-Glance Reminder)
Before acting and before declaring any task done:
- [ ] **Verify** – Read actual code; don't assume paths, signatures, or APIs.
- [ ] **No secrets** – Never log, commit, or expose secrets; use env vars; document in `.env.example`.
- [ ] **Fail fast** – Validate at boundaries; clear errors; don't let invalid state propagate.
- [ ] **Evidence** – Run test, lint, build; show output. Claims without evidence = not done.
- [ ] **Safe defaults** – Deny by default; production-safe config; no silent failures.
- [ ] **Single source of truth** – One place for config, constants, business rules.
- [ ] **Explicit over implicit** – Explicit types, env, config; no magic.
- [ ] **Reuse first** – Before implementing, check if the problem or solution already exists (branch, PRs, codebase); avoid doing the same work twice.

See `02-task-completion.mdc` for mandatory commands and delivery summary; `03-security.mdc` for validation and auth. **In Agent/Auto**, follow the response template and evidence rules in `98-agent-quality.mdc` (Goal → Read/Verify → Plan → Do → Verify with output).

### Where to Look (by Topic)
When the task touches a topic, open the rule file and follow it.

| Topic | Rule file |
|-------|-----------|
| API design, REST | `13-api-design.mdc` |
| API docs (OpenAPI, etc.) | `17-api-documentation.mdc` |
| Auth, validation, secrets, rate limit | `03-security.mdc`, `26-rate-limiting.mdc` |
| Dependencies (add/upgrade) | `15-dependencies.mdc` |
| Errors, retries | `04-error-handling.mdc` |
| Logging, observability | `05-logging.mdc`, `07-observability.mdc` |
| i18n, translations | `06-i18n.mdc` |
| Testing | `11-testing.mdc` |
| Database, schema, queries | `12-database.mdc` |
| TypeScript | `10-typescript.mdc` |
| React, Next.js, UI | `14-react-nextjs.mdc` |
| Accessibility | `16-accessibility.mdc` |
| Git, commits, PRs | `01-git-workflow.mdc` |
| Code review | `09-code-review.mdc` |
| External services, caching, background jobs | `08-external-services.mdc`, `18-caching.mdc`, `24-background-jobs.mdc` |
| Feature flags, monorepo, WebSocket, mobile | `25-feature-flags.mdc`, `20-monorepo.mdc`, `21-websocket.mdc`, `22-mobile.mdc` |

**By task type** (open these together when relevant): API change → 13 + 04; New or changed dependency → 15; UI/frontend change → 14 + 16 (a11y); Auth or user input → 03; Bug fix → 04 + 11 (tests); Performance or caching → 18 + 07.

## Language & Tone
- Always respond in English
- Use clear, internationally understood English - avoid regional slang or idioms
- Avoid words with double meanings or that only exist in specific regions
- Be friendly and approachable, like a coworker you enjoy working with
- Keep it natural - warm but professional, not over-the-top
- Celebrate wins briefly, acknowledge challenges constructively
- Use casual language when appropriate ("Nice!", "Let's do this", "Hmm, interesting...")
- Avoid excessive enthusiasm or forced positivity

## Confidence (95%+ Required)
Before ANY action, verify:
- Information is correct (read actual code)
- Approach will work
- Won't break existing functionality

**If uncertain: STOP → ASK → INVESTIGATE**

## External Tools
Before using any external tool or CLI command:

1. **Check if MCP exists** - If an MCP server provides the functionality, prefer MCP
2. **Verify tool is installed** - Run `which <tool>` or `<tool> --version`
3. **If not installed** - Ask before installing: "I need `<tool>` to proceed. Should I install it?"
4. **Never assume availability** - Even common tools (gh, docker, aws) may not be installed

### Tool Priority
```
1. MCP (if available) → Preferred, integrated experience
2. CLI (if installed)  → Fallback, verify first
3. Ask to install      → Only with user permission
```

### Examples
```bash
# ✅ Check first
which gh && gh pr create ...

# ❌ Don't assume
gh pr create ...  # May fail if gh not installed
```

## Explicit Over Implicit
- Prefer explicit types, explicit dependencies, and explicit configuration. Avoid "magic" that hides behavior.
- Env vars, feature flags, and config should be named and documented; avoid implicit defaults that differ per environment.

## Anti-Hallucination
| ❌ NEVER | ✅ ALWAYS |
|----------|-----------|
| Invent file paths | Verify with glob/read |
| Assume signatures | Read the definition |
| Guess APIs | Check route/controller |
| Make up versions | Look up or omit |

## Secrets & Environment
- **Never** log, commit, or expose secrets (API keys, passwords, tokens). Use environment variables or a secret manager.
- Required env vars MUST be documented in `.env.example` (with placeholder values, no real secrets).
- Validate required env at startup or first use; fail fast with a clear message listing what is missing.
- See `03-security.mdc` for input validation and auth; keep this principle in mind for every new feature.

## Type Safety (Zero Tolerance)
- **NEVER** use `any`, `@ts-ignore`, `@ts-expect-error`
- Use `unknown` + type guards instead

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `data: any` | `data: unknown` |
| `// @ts-ignore` | Fix the type error |
| `// @ts-expect-error` | Add proper types |
| `(obj as any).prop` | Type guard + assertion |

```typescript
// ❌ NEVER
function process(data: any) {
  return data.value;
}

// ✅ CORRECT
function process(data: unknown): string {
  if (typeof data === 'object' && data !== null && 'value' in data) {
    return String(data.value);
  }
  throw new Error('Invalid data');
}
```

## Code Style
- DRY, SOLID, KISS
- Small functions (< 30 lines)
- Meaningful names
- No magic numbers
- Single export per file
- For functions with many arguments, pass one options object; when returning several values, return an object (receive object, return object)
- File order: main export first, then subcomponents, helpers, static content, types (so the file reads top-down by importance)
- Design for change: isolate business logic from the framework; prefer dependency inversion (depend on abstractions, not concretions)
- Prefer composition over inheritance; define interfaces for contracts between layers
- Use braces for all control structures (if, for, while, etc.); consider a consistent line length per project (e.g. 80–120) when the team has a standard
- When defining project rules, include project structure, key libraries, and common patterns so the AI has context
- Verify information before presenting it; do not assume or speculate without evidence; make changes file by file when editing multiple files
- Do not show or discuss the current implementation unless specifically requested; prefer links to real files over generated context
- Consider security implications when suggesting changes; suggest unit tests for new or modified code; handle edge cases explicitly
- **Never swallow errors**: no empty catch; log with context, rethrow or handle. Never fail silently. See `04-error-handling.mdc` for format and retry strategy.

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `const x = 86400` | `const SECONDS_PER_DAY = 86400` |
| `if (status === 1)` | `if (status === Status.ACTIVE)` |
| `function doStuff()` | `function calculateTotalPrice()` |
| `const data = []` | `const userEmails: string[] = []` |
| `function bigFunc() { ... 100 lines }` | Split into smaller functions |

### Fail-Fast & Validation at Boundaries
- Validate inputs at system boundaries (API, CLI, queue handlers). Invalid data must not propagate.
- Fail fast with a clear, actionable error message. Do not allow invalid state to persist or spread.
- See `03-security.mdc` for the full validation pipeline; see `04-error-handling.mdc` for error format.

### Immutability & Explicit Side Effects
- Prefer immutable data: avoid mutating arguments or shared state when a copy is feasible.
- Make side effects explicit (I/O, network, DB, logging). Isolate them so logic is easy to test and reason about.

### Single Source of Truth
- Config, constants, and business rules live in one place. No duplicated magic values or logic across files.
- Reduces bugs and keeps automation (scripts, CI) aligned with the real behavior.

```typescript
// ❌ NEVER - magic numbers, unclear names
function calc(a, b) {
  return a * 0.1 + b * 86400;
}

// ✅ CORRECT - meaningful names, constants
const TAX_RATE = 0.1;
const SECONDS_PER_DAY = 86400;

function calculateTotalWithTax(subtotal: number, days: number): number {
  const tax = subtotal * TAX_RATE;
  const durationInSeconds = days * SECONDS_PER_DAY;
  return subtotal + tax;
}
```

## Comments Policy
**Code should be self-explanatory in English.** Only add comments when:
- Complex algorithm that can't be simplified
- Non-obvious business rule ("// Tax exempt per regulation X")
- Workaround for external issue ("// Bug in library v1.2.3")
- JSDoc for public APIs
- AAA pattern in tests (`// Arrange`, `// Act`, `// Assert` only)

| ❌ NEVER | ✅ ACCEPTABLE |
|----------|---------------|
| `// increment counter` | `// Retry 3x per RFC-7231` |
| `// get user` | `// Workaround for Prisma#1234` |
| `// loop through items` | JSDoc with @param, @returns |
| `// Arrange - set up data` | `// Arrange` |

## Self-Documenting Code
- Variable and function names MUST convey intent
- If you need a comment to explain code, rewrite the code instead
- Code should read naturally in English

| ❌ NEVER | ✅ CORRECT |
|----------|------------|
| `const d = new Date()` | `const createdAt = new Date()` |
| `const arr = users.filter(u => u.a)` | `const activeUsers = users.filter(user => user.isActive)` |
| `function process(x)` | `function sendWelcomeEmail(user)` |
| `const flag = true` | `const shouldRetryOnFailure = true` |
| `// Check if user is admin` + `if (u.r === 1)` | `if (user.role === Role.ADMIN)` |

```typescript
// ❌ NEVER - needs comment to understand
// Get users who signed up in the last 30 days and are active
const res = data.filter(x => x.d > Date.now() - 2592000000 && x.s === 1);

// ✅ CORRECT - self-explanatory, no comment needed
const THIRTY_DAYS_IN_MS = 30 * 24 * 60 * 60 * 1000;
const thirtyDaysAgo = Date.now() - THIRTY_DAYS_IN_MS;

const recentActiveUsers = users.filter(user => 
  user.signupDate > thirtyDaysAgo && user.status === UserStatus.ACTIVE
);
```

## Documentation (README.md) - MANDATORY
**Every task completion MUST include a README check.**

### Before Marking Any Task Complete
Ask yourself: "Does this change affect how someone uses or sets up the project?"

If YES, update README.md:
- New environment variables → Add to Environment Variables table
- New API endpoints → Add to API Design section
- Authentication changes → Update Authentication section
- New commands or scripts → Add to Scripts table
- Changed setup steps → Update Getting Started
- New dependencies with setup → Document installation
- Architecture changes → Update Project Structure
- New features → Document usage

### README Update Checklist
```
□ Does this add/change environment variables?
□ Does this add/change API endpoints?
□ Does this add/change CLI commands or scripts?
□ Does this change setup or installation steps?
□ Does this add new dependencies that need configuration?
□ Does this change authentication or authorization?
□ Does this add a new feature users need to know about?
```

**If any checkbox is YES → Update README before completing the task.**

**Keep it concise.** Don't document obvious things.
**This is not optional.** Task is incomplete without README verification.

For shared repositories, keep CONTRIBUTING.md (and ARCHITECTURE.md when useful) with decisions and structure so contributors know how to work with the codebase.

## Reuse First
Before implementing a fix or new code, **search for an existing solution**; reuse instead of redoing.

### How to check (GitHub / GitLab / branches)
- **PRs (GitHub)** or **MRs (GitLab)**: If the CLI is installed, use it to list and inspect content. Verify first: `which gh` or `which glab`.
  - **GitHub**: `gh pr list` (open PRs), `gh pr view <number>` (content/diff), `gh pr checks <number>` (CI status).
  - **GitLab**: `glab mr list` (open MRs), `glab mr view <number>` (content/diff), `glab mr status` (CI status).
- **Remote branches**: Check other branches on the remote, not only open PRs/MRs. After `git fetch origin`, run `git branch -r` to list remote branches; inspect relevant ones (e.g. same base, or branches that might already contain a fix).
- **Source branch**: Check the branch you're merging into (e.g. main, staging): does the same failure or fix already exist there?

| Area | Check | Reuse |
|------|--------|--------|
| **Pipeline failure** | Source branch + **all open PRs/MRs** (list + view content) + **remote branches** where relevant. Same failure? Existing fix? | Cherry-pick, rebase onto fix, or apply the same approach. See `01-git-workflow.mdc` → CI/CD. |
| **Dependencies** | Is the dependency or a native alternative already in the project? | Use existing; add new only if needed. See `15-dependencies.mdc`. |
| **Code / patterns** | Similar logic or fix in codebase, another branch, or a PR/MR? | Copy or adapt the pattern; don't reimplement from scratch. |
| **Bugs / config** | Same error or config in other environments, PRs/MRs, or branches? | Apply the same fix or document the shared solution. |

When in doubt, a quick check (list PRs/MRs, view content, list remote branches) can avoid duplicate work.

## Think Before You Code
For non-trivial tasks:
1. **Clarify** - Ask questions, understand requirements
2. **Propose** - Present approach, wait for approval
3. **Decompose** - Split into small, verifiable steps
4. **Implement** - Only then write code

**Don't start coding until the approach is clear.**

## Scope Control
- Complete ONE task fully before starting another
- Ask before expanding scope
- Max 3-5 files per task

## Backward Compatibility
- Do not break existing callers, APIs, or config without a plan. Document breaking changes and migration steps.
- See `02-task-completion.mdc` for the pre-completion checklist (includes "Backward compatible").

## Verification Before Completion
Before declaring any task done:
1. **Run the code** - Actually execute, don't assume
2. **Test the change** - Verify it works as expected
3. **Check side effects** - Ensure nothing else broke
4. **Evidence** - Show proof it works (output, test results)

**Claims without evidence = not done.**

## Secure & Safe Defaults
- **Deny by default** for permissions and dangerous operations. Require explicit opt-in for risky behavior.
- Default config and feature flags should be safe for production (e.g. no debug mode on by default).
- See `03-security.mdc` for auth, validation, and audit logging.

## Reproducibility & Automation
- **Lock dependencies** (package-lock, requirements.txt, etc.). Reproducible builds are mandatory.
- Prefer **scriptable, non-interactive** commands for CI: document exit codes and expected outputs.
- Mandatory verification commands (test, lint, build) are defined in `02-task-completion.mdc`; run them before declaring any task done.

## Self-Correction
When you make a mistake:
1. Acknowledge clearly
2. Explain why
3. Fix immediately
4. State prevention

## Pattern Detection (Proactive)
When you notice the user requesting the same thing 2+ times in a conversation:
1. **Identify** - Recognize the repeated pattern
2. **Check** - Verify if it's already in `.cursor/rules/`
3. **Suggest** - Ask: "I noticed you've requested [X] multiple times. Should I add this to `.cursor/rules/` to automate it?"
4. **Recommend** - Suggest the appropriate rule file:
   - Code style → `00-core.mdc`
   - Git workflow → `01-git-workflow.mdc`
   - Task completion → `02-task-completion.mdc`
   - Security → `03-security.mdc`
   - Testing → `11-testing.mdc`
   - API design → `13-api-design.mdc`
   - New category → Create new numbered file (see Rule File Naming in this file)

**Examples of detectable patterns:**
- "Run tests before finishing" → Add to `02-task-completion.mdc`
- "Use specific naming convention" → Add to `00-core.mdc`
- "Always check lints" → Add to `02-task-completion.mdc`
- "Follow specific commit format" → Add to `01-git-workflow.mdc`

## Writing Rules (Agnostic by Default)
When creating or modifying rules in `.cursor/rules/`:

1. **Technology Agnostic** - Write rules that apply across similar technologies
   - Use generic terms: "ORM" not "Prisma", "framework" not "Next.js"
   - Provide examples for multiple languages/frameworks when possible
   - Avoid hardcoding specific library names unless the rule is framework-specific

2. **Pattern Over Implementation** - Focus on the "what" and "why", not the "how"
   ```markdown
   ✅ "Use connection pooling for database connections"
   ❌ "Set Prisma connection pool to 10"
   ```

3. **Reusability Checklist**
   - [ ] Could this rule apply to Python, Go, Ruby, etc.?
   - [ ] Are examples generic enough to adapt?
   - [ ] Is the principle clear without specific library knowledge?

4. **When Framework-Specific is Necessary**
   - Create separate rule files: `14-react-nextjs.mdc`, `23-ruby.mdc`
   - Use glob patterns to auto-apply: `globs: "**/*.rb"`
   - Still document the underlying principle, not just the syntax

5. **Rule File Naming**
   - `00-09`: Core principles (always apply)
   - `10-19`: Language-specific (TypeScript, etc.)
   - `20-29`: Architecture patterns (monorepo, websocket, etc.)
   - `30-39`: Language-specific (Ruby, Go, Python, etc.)
   - `90-99`: Meta rules (agent router, etc.)

6. **Clarity and Maintenance**
   - Keep rules concise; avoid redundant instructions; use clear, unambiguous language.
   - Review rules periodically. If a rule doesn't seem to apply: check syntax and path (`.cursor/rules`), restart Cursor; note that global rules can override project rules.

## Automation-Friendly Workflows
- Prefer **idempotent** operations where possible (scripts, migrations, deploys). Document when something is not idempotent.
- Prefer **non-interactive** commands for CI and scripts; avoid prompts that block automation.
- When adding scripts or CLI: document required env, exit codes (0 = success, non-zero = failure), and how to run in CI.

## When the Rules Don't Specify
- Prefer the option that is **safer** (no extra risk), **more explicit** (no hidden behavior), and **easier to automate** (scriptable, reproducible).
- If two approaches are equivalent, choose the one that is easier to test and maintain.
- When in doubt, ask or reference the relevant rule file (`02-task-completion.mdc`, `03-security.mdc`, etc.).
